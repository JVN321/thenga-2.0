# Flask chatbot server with Gemini API and text-to-speech
from flask import Flask, request, jsonify, send_file, render_template
import requests
import os
import tempfile
import json
from gtts import gTTS
from datetime import datetime
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

app = Flask(__name__)

# Get Gemini API key from environment variables
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY environment variable is not set. Please check your .env file.")

# Updated Gemini API URL - use the correct model endpoint
GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent'

# Store conversation history
conversation_history = []

def detect_language(text):
    """Detect if text contains Malayalam characters"""
    # Malayalam Unicode range: 0D00-0D7F
    malayalam_chars = any('\u0d00' <= char <= '\u0d7f' for char in text)
    return 'ml' if malayalam_chars else 'en'

def ask_gemini(message, language='en'):
    """Send message to Gemini API and get response in specified language"""
    headers = {'Content-Type': 'application/json'}
    params = {'key': GEMINI_API_KEY}
    
    # Add context about ESP32 integration and language preference
    if language == 'ml':
        context = """You are a helpful assistant that can control ESP32 devices. When users ask about hardware control, provide clear instructions. 
        Please respond in Malayalam (മലയാളം) when the user writes in Malayalam, and in English when they write in English. 
        If the user writes in Malayalam, try to respond primarily in Malayalam with English technical terms when necessary."""
    else:
        context = """You are a helpful assistant that can control ESP32 devices. When users ask about hardware control, provide clear instructions.
        Please respond in English, but if the user writes in Malayalam, you can acknowledge their language and respond appropriately."""
    
    full_message = f"{context}\n\nUser: {message}"
    
    data = {
        "contents": [{"parts": [{"text": full_message}]}]
    }
    
    try:
        response = requests.post(GEMINI_API_URL, headers=headers, params=params, json=data, timeout=10)
        
        # Enhanced error handling with detailed response information
        if response.status_code == 200:
            result = response.json()
            if 'candidates' in result and len(result['candidates']) > 0:
                return result['candidates'][0]['content']['parts'][0]['text']
            else:
                return "Error: No response generated by Gemini API"
        elif response.status_code == 400:
            error_detail = response.json() if response.content else "Bad request"
            return f"Error 400: Invalid request - {error_detail}"
        elif response.status_code == 403:
            return "Error 403: API key invalid or quota exceeded. Please check your Gemini API key."
        elif response.status_code == 404:
            return f"Error 404: API endpoint not found. Please check the model name. URL used: {GEMINI_API_URL}"
        else:
            error_detail = response.text if response.content else "Unknown error"
            return f"Error: API returned status {response.status_code} - {error_detail}"
            
    except requests.exceptions.RequestException as e:
        return f"Error connecting to Gemini API: {str(e)}"
    except Exception as e:
        return f"Error processing response: {str(e)}"

# Text-to-speech endpoint
@app.route('/tts', methods=['POST'])
def tts():
    try:
        # Check if request has JSON data
        if not request.json:
            return jsonify({'error': 'No JSON data provided'}), 400
            
        text = request.json.get('text', '')
        language = request.json.get('language', '')  # Don't default to 'en'
        
        if not text:
            return jsonify({'error': 'No text provided'}), 400
        
        # Auto-detect language if not specified
        if not language:
            language = detect_language(text)
        
        # Validate language code
        supported_languages = {
            'en': 'English',
            'ml': 'Malayalam',
            'hi': 'Hindi',
            'ta': 'Tamil',
            'te': 'Telugu'
        }
        
        if language not in supported_languages:
            language = 'en'  # Fallback to English
        
        try:
            tts_engine = gTTS(text=text, lang=language, slow=False)
            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.mp3')
            tts_engine.save(temp_file.name)
            temp_file.close()
            
            return send_file(temp_file.name, mimetype='audio/mpeg', as_attachment=True, download_name=f'speech_{language}.mp3')
        except Exception as tts_error:
            # If specified language TTS fails, try English as fallback
            if language != 'en':
                try:
                    tts_engine = gTTS(text=text, lang='en', slow=False)
                    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.mp3')
                    tts_engine.save(temp_file.name)
                    temp_file.close()
                    return send_file(temp_file.name, mimetype='audio/mpeg', as_attachment=True, download_name='speech_en_fallback.mp3')
                except:
                    pass
            raise tts_error
            
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# Add endpoint to get supported languages
@app.route('/languages', methods=['GET'])
def get_languages():
    supported_languages = {
        'en': 'English',
        'ml': 'Malayalam (മലയാളം)',
        'hi': 'Hindi (हिंदी)',
        'ta': 'Tamil (தமிழ்)',
        'te': 'Telugu (తెలుగు)'
    }
    return jsonify({'languages': supported_languages})

# Add endpoint to get sample phrases
@app.route('/sample_phrases', methods=['GET'])
def get_sample_phrases():
    sample_phrases = {
        'en': [
            "Turn on the LED",
            "What is the temperature?",
            "Check ESP32 status",
            "How are you?",
            "Tell me about IoT"
        ],
        'ml': [
            "LED ഓൺ ചെയ്യൂ",
            "താപനില എത്രയാണ്?",
            "ESP32 ന്റെ അവസ്ഥ പരിശോധിക്കൂ",
            "എങ്ങനെയുണ്ട്?",
            "IoT കുറിച്ച് പറയൂ"
        ]
    }
    return jsonify({'sample_phrases': sample_phrases})

# Home page with chat interface
@app.route('/')
def home():
    return render_template('index.html')

# Chatbot endpoint
@app.route('/chat', methods=['POST'])
def chat():
    try:
        # Check if request has JSON data
        if not request.json:
            return jsonify({'error': 'No JSON data provided'}), 400
            
        user_message = request.json.get('message', '')
        if not user_message:
            return jsonify({'error': 'No message provided'}), 400
        
        # Detect language of user input
        detected_language = detect_language(user_message)
        
        # Store user message in history with language info
        conversation_history.append({
            'timestamp': datetime.now().isoformat(),
            'type': 'user',
            'message': user_message,
            'language': detected_language
        })
        
        # Get response from Gemini with language context
        bot_reply = ask_gemini(user_message, detected_language)
        
        # Store bot response in history with language info
        conversation_history.append({
            'timestamp': datetime.now().isoformat(),
            'type': 'bot',
            'message': bot_reply,
            'language': detected_language
        })
        
        return jsonify({
            'reply': bot_reply,
            'detected_language': detected_language,
            'suggested_tts_language': detected_language
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# ESP32 endpoint example: receive command and respond
@app.route('/esp32', methods=['POST'])
def esp32():
    try:
        # Check if request has JSON data
        if not request.json:
            return jsonify({'error': 'No JSON data provided'}), 400
            
        command = request.json.get('command', '')
        if not command:
            return jsonify({'error': 'No command provided'}), 400
        
        # Here you can add logic to trigger functions on ESP32
        # For example, send HTTP requests to ESP32 or use MQTT
        if command == 'turn_on_led':
            result = 'LED turned on successfully.'
        elif command == 'turn_off_led':
            result = 'LED turned off successfully.'
        elif command == 'get_status':
            result = 'ESP32 status: Online and ready.'
        elif command == 'read_sensors':
            result = 'Temperature: 25°C, Humidity: 60%'
        else:
            result = f'Unknown command: {command}. Available commands: turn_on_led, turn_off_led, get_status, read_sensors'
        
        return jsonify({'result': result})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# Get conversation history
@app.route('/history', methods=['GET'])
def get_history():
    return jsonify({'history': conversation_history})

# Clear conversation history
@app.route('/clear_history', methods=['POST'])
def clear_history():
    global conversation_history
    conversation_history = []
    return jsonify({'message': 'History cleared'})

if __name__ == '__main__':
    print("Starting ESP32 Chatbot Server...")
    print("Server will be available at: http://localhost:5000")
    print(f"Using Gemini API URL: {GEMINI_API_URL}")
    if GEMINI_API_KEY:
        print("✓ Gemini API key loaded successfully!")
        # Mask the API key for security
        masked_key = GEMINI_API_KEY[:8] + "..." + GEMINI_API_KEY[-4:] if len(GEMINI_API_KEY) > 12 else "***"
        print(f"API Key: {masked_key}")
    else:
        print("✗ Warning: Gemini API key not found!")
    app.run(host='0.0.0.0', port=5000, debug=True)
